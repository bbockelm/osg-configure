#!/usr/bin/python

import os, sys, getopt, time, ConfigParser, StringIO, re, atexit, shutil

try:
	from configure_osg.modules import exceptions
	from configure_osg.modules import utilities
except ImportError:
	sys.exit("Required modules missing, did you source setup.sh?")



py23 = sys.version_info[0] == 2 and sys.version_info[1] >= 3

class FakeLogger:
  """
  Super simple logger for python installs which don't have the logging
  package.
  """
  def __init__(self, loglevel="info"):
    self.loglevel = loglevel  

  def debug(self, msg, *args):
    if self.loglevel == "debug":                       
      print >> sys.stderr, "configure-osg: DEBUG    %s" %  msg  
 
  def info(self, msg, *args):
    print >> sys.stderr, "configure-osg: INFO     %s" % msg
    print >> sys.stderr, msg
 
  def warning(self, msg, *args):
    print >> sys.stderr, "configure-osg: WARNING  %s" % msg
 
  def critical(self, msg, *args):
    print >> sys.stderr, "configure-osg: CRITICAL %s" % msg
 
  def error(self, msg, *args):
    print >> sys.stderr, "configure-osg: ERROR    %s" % msg  
 
  def exception(self, msg, *args):
    print >> sys.stderr, "configure-osg: UNEXPECTED EXCEPTION  %s" % msg 
       
if py23:
  import logging



############################# Constant Definitions ############################

  
CONFIGURE = 1
VERIFY = 2
LIST = 4
config_location = os.path.join('osg', 'etc', 'osg-configuration.ini')
job_environment_attributes = ['OSG_LOCATION',  
                              'GLOBUS_LOCATION', 
                              'OSG_SITE_NAME', 
                              'GRID3_SITE_NAME', 
                              'OSG_HOSTNAME', 
                              'OSG_GRID', 
                              'GRID3_BASE_DIR', 
                              'OSG_APP', 
                              'GRID3_APP_DIR', 
                              'OSG_DATA', 
                              'GRID3_DATA_DIR', 
                              'GRID3_TMP_DIR', 
                              'OSG_WN_TMP', 
                              'GRID3_TMP_WN_DIR', 
                              'OSG_STORAGE_ELEMENT', 
                              'OSG_DEFAULT_SE', 
                              'OSG_SITE_READ', 
                              'OSG_SITE_WRITE', 
                              'OSG_SQUID_LOCATION', 
                              'OSG_JOB_CONTACT', 
                              'OSG_GLEXEC_LOCATION']


############################# Global Variables ############################

# attributes dictionary has the following structure 
# key = attribute name
# value = tuple (attribute type, attribute value)
# attribute type is either local, main, or gip to indicate whether the attribute
# should is a local site attribute, osg attribute or gip attribute
attributes = {}

# if true verification is not required to configure system
force = False


############################# Function Definitions ############################

  
def real_error_exit(logger, message="Critical error occurred, exiting", exception = None):
  """Function to do all the cleanup and exit if an error occurs"""  
  logger.critical(message)
  if exception is not None:
    logger.critical("Exception: %s" % (exception))
  sys.stderr.write("%s\n" % message)
  sys.stderr.write("You may be able to get more details rerunning configure-osg with the -d option " \
									 "and/or by examining %s\n" % (os.path.join(utilities.get_vdt_location(), 'vdt-install.log')))
  sys.exit(1)

def real_normal_exit(logger, message="Configuration completed, exiting..."):
  """Function to do all the cleanup and exit"""  
  logger.info(message)
  sys.stdout.write("%s\n" % message)
  sys.exit(0)
 
# The next two functions are redefined in the main() function once the logger
# has been set up
def error_exit(msg, exception=None):
    fl = FakeLogger()
    real_error_exit(fl, message=msg, exception=exception)

def normal_exit(msg):
    fl = FakeLogger()
    real_normal_exit(fl, message=msg)
 
def vdt_finish():
  """End vdt installation"""  
  os.system("/bin/echo '########## [configure-osg] completed' >> %s/vdt-install.log" \
            % utilities.get_vdt_location())

def set_python_path():
  """Set up python import path to include the directory that the 
  application is running from
  """
  script_dir = os.path.split(os.path.realpath(sys.argv[0]))[0]
  sys.path.append(script_dir)
  
def get_configuration_modules(vdt_location, logger):
  """Instantiate and return modules in configure_modules directory"""  
  try:
    start_dir = os.path.split(os.path.realpath(sys.argv[0]))[0]
    modules = os.listdir(os.path.join(utilities.get_vdt_location(),
                                      "osg",
                                      "lib",
                                      "python",
                                      "configure_osg",
                                      "configure_modules"))
  except OSError, exception:
    error_exit("Can't get configuration modules, exiting...", exception)
    
  objects = []
  for module in modules:      
    if module.split(".")[-1] == "py" and module != "__init__.py":
      module_name = module.split(".")[0]
      module_ref = __import__('configure_osg.configure_modules.' + module_name, 
                              globals(),
                              locals(),
                              [''])
      objects.append(getattr(module_ref, module_ref.__all__[0])(logger=logger))
  return objects

def usage():
  """Print usage information"""
  sys.stderr.write("%s -h -c -v -l -d -o "  % sys.argv[0])
  sys.stderr.write("[output-directory] -m [module]\n")
  sys.stderr.write("Usage: \n")
  sys.stderr.write("-h help\n")
  sys.stderr.write("-d output debug messages to the log (applicable with ")
  sys.stderr.write("any other option)\n")
  sys.stderr.write("\n")
  sys.stderr.write("To configure an installation, use the -c option and any ")
  sys.stderr.write("of the options below:\n")
  sys.stderr.write("-m module to configure (this option will try to configure ")
  sys.stderr.write("only the specified module).  This is optional.\n")
  sys.stderr.write("\n") 
  sys.stderr.write("To verify a configuration file, use the -v option\n")
  sys.stderr.write("\n") 
  sys.stderr.write("To list configuration modules available and get information ")
  sys.stderr.write("about modules, use the -l option\n")
  
def read_config_file(configuration_file, case_sensitive=False):
  """Read configuration file and return ConfigParse object for file"""
  # instantiate ConfigParser or SafeConfigParser (if running under 
  # python 2.4+) object, if case_sensitive is true then return a case 
  # sensitive parser
  if sys.version_info[0] >= 2 and sys.version_info[1] >= 4:
    config = ConfigParser.SafeConfigParser()
    local_config = ConfigParser.SafeConfigParser()
  else:
    config = ConfigParser.ConfigParser()

  
  if case_sensitive:    
    config.optionxform = str
    
  # read configuration file
  try:
    real_fp = open(configuration_file, 'r')
    string_fp = StringIO.StringIO(real_fp.read())    
    config.readfp(string_fp)
    if not utilities.valid_ini_file(configuration_file):
      error_mesg = "Invalid ini file, one or more sections are duplicated "
      error_mesg += "or a line with a setting starts with whitespace, "
      error_mesg += "exiting..."
      error_exit(error_mesg)
    if utilities.config_template(config):
      error_mesg = "config.ini file appears to be the default template file, "
      error_mesg += "please make sure that it has been properly filled out. "
      error_mesg += "Exiting..."
      error_exit(error_mesg)      
  except OSError, exception:
    error_exit("Can't read configuration file", exception)  
  except IOError, exception:
    error_exit("Can't read configuration file", exception)
  except ConfigParser.ParsingError, exception:
    error_exit("Can't parse configuration file", exception)
  
  return config

def save_config(configuration_file, logger):
  """
  Save configuration file to vdt location for gip to read and for future reference
  """
  backup_path = os.path.join(utilities.get_vdt_location(),
                             'osg',
                             'etc',
                             'configs')
  if not os.path.exists(backup_path):
    os.mkdir(backup_path)
  os.chmod(backup_path, 0755)
   
  time_info = time.gmtime()
  
  backup_file = '%04d%02d%02d-%02d%02d%02d-config.ini' % (time_info[0],
                                                          time_info[1],
                                                          time_info[2],
                                                          time_info[3],
                                                          time_info[4],
                                                          time_info[5])
  backup_file = os.path.join(backup_path, backup_file)
  link_file = os.path.join(backup_path, 'current-config.ini')
  try:
    shutil.copy(configuration_file, backup_file)
    if os.path.exists(link_file):
      os.remove(link_file)
    os.symlink(backup_file, link_file)
  except Exception, ex:
    error_exit("Can't make copy of current config (%s)")
  
  
  

def write_attributes(output_directory,
                     attributes,
                     local_site_attributes,
                     job_environment_attributes):
  """Write out attributes to osg config files in output_directory"""
  # write out osg-attributes.conf
  # This does not write gip attributes since that needs to be done in the 
  # gip configure method in order for configure_gip to work
  try:
    filename = os.path.join(output_directory, "osg-attributes.conf")
    utilities.write_attribute_file(filename, attributes)
  except IOError, exception:
    error_exit("Error writing attributes to osg-attributes.conf", exception)
     
    
  # write out osg-local-job-environment.conf
  try:
    filename = os.path.join(output_directory, "osg-local-job-environment.conf")
    utilities.write_attribute_file(filename, local_site_attributes)
  except IOError, exception:
    error_exit("Error writing attributes to osg-local-job-attributes.conf", exception)


  # write out osg-job-environment.conf
  try:
    filename = os.path.join(output_directory, "osg-job-environment.conf")
    temp = {}
    for key in job_environment_attributes:
      try:
        temp[key] = attributes[key]
      except KeyError, exception:
        error_exit("Missing job environment key (%s), exiting." % key, exception)      
    utilities.write_attribute_file(filename, temp)
  except IOError, exception:
    error_exit("Error writing attributes to osg-job-environment.conf", exception)

    
def configure_system(configuration_file, output_directory, modules, 
                     logger, configure_module = None):
  """Read configuration files and try to configure the osg system"""

  if not modules:
    error_exit("No modules found, exiting")

  if not utilities.valid_location(output_directory):
    error_exit("Output directory %s not present" % output_directory)
  if not utilities.valid_file(configuration_file):
    error_exit("Configuration file %s does not exist" % configuration_file)

  config = read_config_file(configuration_file)

  if not utilities.ce_config(config):
		logger.warning("No job managers enabled, assuming this is not a CE")

  for module in modules:
    try:
      if  module.__class__.__name__ == 'LocalSettings':
        local_config = read_config_file(configuration_file, True)
        module.parseConfiguration(local_config)
        continue
      else:
        module.parseConfiguration(config)
    except exceptions.SettingError, exception:
      error_exit("Error in %s while parsing configuration" % \
                 (module.__class__.__name__),
                 exception )
#    except ConfigParser.InterpolationSyntaxError, exception:
#      error_exit("Error while parsing configuration, check your variables for " +
#                 "a missing s after the paranthesis")
    except ConfigParser.ParsingError, exception:
      error_exit("Error while parsing configuration: %s" % exception)
    
  attributes = {}
  local_attributes = {}
  legacyConfig = None
  monalisaConfig = None
  localConfig = None
  for module in modules:
    if  module.__class__.__name__ == 'LocalSettings':
      local_attributes.update(module.getAttributes())

    if module.__class__.__name__ == 'LegacyConfiguration':
      # need to configuration LegacyConfiguration after other modules
      # since it derives it's settings from other modules
      # and uses the attributes dictionary for this
      legacyConfig = module
    elif module.__class__.__name__ == 'MonalisaConfiguration':
      # need to configuration MonaLisaConfiguration after other modules
      # since it derives it's settings from other modules
      # and uses the attributes dictionary for this
      monalisaConfig = module
    else:
      attributes.update(module.getAttributes())

  legacyConfig.configure(attributes)
  attributes.update(legacyConfig.getAttributes())
      
  
  if not check_configuration(modules, configuration_file, attributes, logger):
    if force:
      logger.warn("Invalid attributes found but forcing configuration.")
      sys.stderr.write("Invalid attributes found but forcing configuration.\n")
    else:
      error_exit("Invalid attributes found, exiting")
        
  for module in modules:
    logger.debug("Configuring %s" % (module.__class__.__name__))
    if configure_module is not None:
      if module.moduleName().lower() != configure_module:
        logger.debug("Skipping %s configuration" % (module.__class__.__name__))
        continue
    try:
      module.configure(attributes)
    except exceptions.ConfigureError, e:
      logger.debug("Got ConfigureError %s" % e)
      error_exit("Can't configure module, exiting")

  if configure_module is None:
    # need to configure monalisa after job managers
    monalisaConfig.configure(attributes)

  save_config(configuration_file, logger)
  if not utilities.ce_config(config):
    # no need to write out attribute files on non-ce installations
    return
  
  write_attributes(output_directory, 
                   attributes, 
                   local_attributes,
                   job_environment_attributes)

def verify_system(configuration_file, modules, logger):
  """Read configuration files and try to verify the configuration 
  to make sure that it's sane and points to valid information
  """
  if modules == []:
    error_exit("No modules found, exiting")

  if not utilities.valid_file(configuration_file):
    error_exit("Configuration file %s does not exist" % configuration_file)
  
  config = read_config_file(configuration_file)
  
  for module in modules:
    try:
      if  module.__class__.__name__ == 'LocalSettings':
        local_config = read_config_file(configuration_file, True)
        module.parseConfiguration(local_config)
        continue
      else:
        module.parseConfiguration(config)
    except exceptions.SettingError, exception:
      error_exit("Error in %s while parsing configuration" % (module.__class__.__name__),
                 exception )
#    except ConfigParser.InterpolationSyntaxError, exception:
#      error_exit("Error while parsing configuration, check your variables for " +
#                 "a missing s after the paranthesis")
    except ConfigParser.ParsingError, exception:
      error_exit("Error while parsing configuration: %s" % exception)
      
  attributes = {}
  local_attributes = {}
  legacyConfig = None
  for module in modules:
    if  module.__class__.__name__ == 'LocalSettings':
      local_attributes.update(module.getAttributes())
    if module.__class__.__name__ == 'LegacyConfiguration':
      # need to configuration LegacyConfiguration after other modules
      # since it derives it's settings from other modules
      # and uses the attributes dictionary for this
      legacyConfig = module
    else:
      attributes.update(module.getAttributes())

  legacyConfig.configure(attributes)
  attributes.update(legacyConfig.getAttributes())
      
  if not check_configuration(modules, configuration_file, attributes, logger):
    error_exit("Invalid attributes found, exiting")
  normal_exit("Configuration verified successfully")

def list_modules(modules, logger):
  """Print out a list of all modules available on the system
  """
  if modules == []:
    error_exit("No modules found, exiting")
  
  sys.stdout.write("%s%s\n" % ("Module name".ljust(30), "Can configure separately?".ljust(40)))
  for module in modules:
    name = module.moduleName()
    if  module.separatelyConfigurable():
      configurable = "Yes"
    else:
      configurable = "No"
    sys.stdout.write("%s%s\n" % (name.ljust(30), configurable.ljust(40)))                                    
  
  normal_exit("Modules listed successfully")
  
    
def check_configuration(modules, configuration_file, attributes, logger):
  """Read a configuration file and check it to make sure that it will work"""
  # get a list of configuration modules
  
  if modules == []:
    logger.warning("No configuration modules found")
    return False

  config = read_config_file(configuration_file)

  status = True
  for module in modules:
    status &= module.checkAttributes(attributes)
  return status
  
############################# Main Program ##############################

def main():
  global error_exit
  global normal_exit
  
  normal_exit_message = "Configuration completed, exiting..."
  error_exit_message = "Critical error occurred, exiting..."
    
  mode = None
  configure_mode = None
  
  if py23:
    log_level = logging.INFO
  else:                          
    log_level = "info"           
  
  # include application path in list of directories that python checks
  set_python_path()
  
  # get $VDT_LOCATION from environment
  try:
    vdt_location = utilities.get_vdt_location()
  except exceptions.ApplicationError:
    sys.stderr.write("VDT_LOCATION not set, please run setup.sh before trying ")
    sys.stderr.write("to configure your install.\n")
    sys.exit(1)
  
  # log information to vdt-install.log
  
  os.system("/bin/echo '##########' >> %s/vdt-install.log" % vdt_location)
  os.system("/bin/echo '# configure-osg.py invoked at %s' >> %s/vdt-install.log" % (time.ctime(), vdt_location))
  os.system("/bin/echo '##########' >> %s/vdt-install.log" % vdt_location)
  atexit.register(vdt_finish)
  
  try:
    opts, args = getopt.getopt(sys.argv[1:], 'lhdf:D:cvem:', ['force'])
  except getopt.GetoptError:
    usage()
    sys.stderr.write("Can't parse commandline arguments\n")
    sys.exit(1)
  
  config_directory = None
  configure_module = None
  for opt,parameter in opts:
    if opt == "-d": 
      if py23:
        log_level = logging.DEBUG
      else:            
        log_level = "debug"
    elif opt == "-h":
      usage()
      sys.exit(0)
    elif opt == "-D":
      config_directory = parameter
    elif opt == "-c":
      if mode is None:
        mode = CONFIGURE
      else:
        usage()
        sys.exit(1)
    elif opt == "-v":
      if mode is None:
        mode = VERIFY
        normal_exit_message = "Verification completed, exiting..."
      else:
        usage()
        sys.exit(1)
    elif opt == "-l":
      if mode is None:
        mode = LIST
        normal_exit_message = "List modules completed, exiting..."
      else:
        usage()
        sys.exit(1)
    elif opt == "-m":
      configure_module = parameter.lower()
    elif opt == '--force':
      force = True 
      
    
    configuration_file = os.path.join(utilities.get_vdt_location(),
                                      'osg',
                                      'etc',
                                      'config.ini')
    config_directory = os.path.join(utilities.get_vdt_location(),
                                    'osg',
                                    'etc')
    sys.stdout.write("Using %s for configuration information\n" % 
                     configuration_file )
    
  # setup logging
  try:
    if py23:
      logger = logging.getLogger('configure-osg')
      formatter = logging.Formatter('### %(asctime)s configure-osg %(levelname)s %(message)s')
      handler = logging.FileHandler("%s/vdt-install.log" % (vdt_location), 'a')
      logger.setLevel(log_level)
      handler.setFormatter(formatter)
      logger.addHandler(handler)
      console = logging.StreamHandler()
      console.setLevel(logging.ERROR)
      formatter = logging.Formatter('%(name)-12s: %(levelname)-8s %(message)s')
      console.setFormatter(formatter)
      logger.addHandler(console)
        
      error_exit = lambda mesg=error_exit_message, exception=None: real_error_exit(logger, mesg, exception)    
      normal_exit = lambda mesg=normal_exit_message: real_normal_exit(logger, mesg)
      
    else:
      logger = FakeLogger(log_level)
      error_exit = lambda mesg=error_exit_message, exception=None: real_error_exit(logger, mesg, exception)
      normal_exit = lambda mesg=normal_exit_message: real_normal_exit(logger, mesg)
      
  except IOError:
    sys.stderr.write("Can't open vdt-install.log for logging, exiting...\n")
    sys.exit(1)
  
  try:
    # get a list of configuration modules
    modules = get_configuration_modules(vdt_location, logger)
    
    if mode == CONFIGURE:
      # configure settings
      configure_system(configuration_file, config_directory, modules, 
                       logger, configure_module)
    elif mode == VERIFY:
      # verify settings
      verify_system(configuration_file, modules, logger)
    elif mode == LIST: 
      list_modules(modules, logger)
    else:
      usage()
      error_exit("Must specify either -c, -v, or -l")
  except SystemExit:
    # needed since SystemExit inherits from Exception
    raise
  except Exception, e:
    sys.stderr.write("Please contact the developer, an unknown error occurred\n")
    error_exit("Unknown exception encountered while running: %s" % e)  
  
  normal_exit("Configure-osg completed successfully")
  
  
if __name__ == '__main__':
    main()
