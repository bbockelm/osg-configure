#!/usr/bin/python

import os, sys, getopt, time, ConfigParser, StringIO, re, atexit, shutil

from configure_osg.modules import exceptions
from configure_osg.modules import utilities


py23 = sys.version_info[0] == 2 and sys.version_info[1] >= 3

class FakeLogger:
  """
  Super simple logger for python installs which don't have the logging
  package.
  """
  def __init__(self, loglevel="info"):
    self.loglevel = loglevel  

  def debug(self, msg, *args):
    if self.loglevel == "debug":                       
      print >> sys.stderr, "extract-config: DEBUG    %s" %  msg  
 
  def info(self, msg, *args):
    print >> sys.stderr, "extract-config: INFO     %s" % msg
    print >> sys.stderr, msg
 
  def warning(self, msg, *args):
    print >> sys.stderr, "extract-config: WARNING  %s" % msg
 
  def critical(self, msg, *args):
    print >> sys.stderr, "extract-config: CRITICAL %s" % msg
 
  def error(self, msg, *args):
    print >> sys.stderr, "extract-config: ERROR    %s" % msg  
 
  def exception(self, msg, *args):
    print >> sys.stderr, "extract-config: UNEXPECTED EXCEPTION  %s" % msg 
       
if py23:
  import logging



############################# Constant Definitions ############################



############################# Global Variables ############################

# attributes dictionary has the following structure 
# key = attribute name
# value = tuple (attribute type, attribute value)
# attribute type is either local, main, or gip to indicate whether the attribute
# should is a local site attribute, osg attribute or gip attribute
attributes = {}

# if true verification is not required to configure system
force = False


############################# Function Definitions ############################

  
def real_error_exit(logger, message="Critical error occurred, exiting", exception = None):
  """Function to do all the cleanup and exit if an error occurs"""  
  logger.critical(message)
  if exception is not None:
    logger.critical("Exception: %s" % (exception))
  sys.stderr.write("%s\n" % message)
  sys.exit(1)

def real_normal_exit(logger, message="Configuration completed, exiting..."):
  """Function to do all the cleanup and exit"""  
  logger.info(message)
  sys.stdout.write("%s\n" % message)
  sys.exit(0)
 
# The next two functions are redefined in the main() function once the logger
# has been set up
def error_exit(msg, exception=None):
    fl = FakeLogger()
    real_error_exit(fl, message=msg, exception=exception)

def normal_exit(msg):
    fl = FakeLogger()
    real_normal_exit(fl, message=msg)
 
def vdt_finish():
  """End vdt installation"""  
  os.system("/bin/echo '########## [extract-config] completed' >> %s/vdt-install.log" \
            % utilities.get_vdt_location())

def set_python_path():
  """
  Set up python import path to include the directory that the 
  application is running from
  """
  script_dir = os.path.split(os.path.realpath(sys.argv[0]))[0]
  sys.path.append(script_dir)
  
def get_configuration_modules(vdt_location, logger):
  """Instantiate and return modules in configure_modules directory"""  
  try:
    start_dir = os.path.split(os.path.realpath(sys.argv[0]))[0]
    modules = os.listdir(os.path.join(utilities.get_vdt_location(),
                                      "osg",
                                      "lib",
                                      "python",
                                      "configure_osg",
                                      "configure_modules"))
  except OSError, exception:
    error_exit("Can't get configuration modules, exiting...", exception)
    
  objects = []
  for module in modules:      
    if module.split(".")[-1] == "py" and module != "__init__.py":
      module_name = module.split(".")[0]
      module_ref = __import__('configure_osg.configure_modules.' + module_name, 
                              globals(),
                              locals(),
                              [''])
      objects.append(getattr(module_ref, module_ref.__all__[0])(logger=logger))
  return objects

def usage():
  """Print usage information"""
  sys.stderr.write("%s -h -d "  % sys.argv[0])
  sys.stderr.write("Usage: \n")
  sys.stderr.write("-h help\n")
  sys.stderr.write("-d output debug messages to the log \n")
  sys.stderr.write("\n")
  sys.stderr.write("\n")
  
def read_config_file(configuration_file, case_sensitive=False):
  """Read configuration file and return ConfigParse object for file"""
  # instantiate ConfigParser or SafeConfigParser (if running under 
  # python 2.4+) object, if case_sensitive is true then return a case 
  # sensitive parser
  if sys.version_info[0] >= 2 and sys.version_info[1] >= 4:
    config = ConfigParser.SafeConfigParser()
    local_config = ConfigParser.SafeConfigParser()
  else:
    config = ConfigParser.ConfigParser()

  
  if case_sensitive:    
    config.optionxform = str
    
  # read configuration file
  try:
    real_fp = open(configuration_file, 'r')
    string_fp = StringIO.StringIO(real_fp.read())    
    config.readfp(string_fp)
    if utilities.duplicate_sections_exist(configuration_file):
      error_exit('One or more sections in the configuration file are duplicated, exiting')
  except OSError, exception:
    error_exit("Can't read configuration file", exception)  
  except IOError, exception:
    error_exit("Can't read configuration file", exception)
  except ConfigParser.ParsingError, exception:
    error_exit("Can't parse configuration file", exception)
  
  return config

def save_config(configuration_file, logger):
  """
  Save configuration file to vdt location for gip to read and for future reference
  """
  backup_path = os.path.join(utilities.get_vdt_location(),
                             'osg',
                             'etc',
                             'configs')
  if not os.path.exists(backup_path):
    os.mkdir(backup_path)
  os.chmod(backup_path, 0755)
   
  time_info = time.gmtime()
  
  backup_file = '%04d%02d%02d-%02d%02d%02d-config.ini' % (time_info[0],
                                                          time_info[1],
                                                          time_info[2],
                                                          time_info[3],
                                                          time_info[4],
                                                          time_info[5])
  backup_file = os.path.join(backup_path, backup_file)
  link_file = os.path.join(backup_path, 'current-config.ini')
  try:
    shutil.copy(configuration_file, backup_file)
    if os.path.exists(link_file):
      os.remove(link_file)
    os.symlink(backup_file, link_file)
  except Exception, ex:
    error_exit("Can't make copy of current config (%s)")
  
  
def parse_config(configuration_file):
  """
  Read a configuration file and then parse and convert it to the 
  latest config file format
  """
  if sys.version_info[0] >= 2 and sys.version_info[1] >= 4:
    config = ConfigParser.SafeConfigParser()
    local_config = ConfigParser.SafeConfigParser()
  else:
    config = ConfigParser.ConfigParser()
   
  # read configuration file
  try:
    real_fp = open(configuration_file, 'r')
    string_fp = StringIO.StringIO(real_fp.read())    
    config.readfp(string_fp)
    if utilities.duplicate_sections_exist(configuration_file):
      error_exit('One or more sections in the configuration file are duplicated, exiting')
  except OSError, exception:
    error_exit("Can't read configuration file", exception)  
  except IOError, exception:
    error_exit("Can't read configuration file", exception)
  except ConfigParser.ParsingError, exception:
    error_exit("Can't parse configuration file", exception)

  if not config.has_section('GIP'):
    return config

  if config.has_option('GIP', 'sc_number'):
    # parse gip section
    subclusters = []
    num_subclusters = config.getint('GIP', 'sc_number')
    config.remove_option('GIP', 'sc_number')
    for i in range(1, num_subclusters):
      subcluster = {}
      subcluster['name'] = config.get('GIP', "sc_name_%s" % i)
      subcluster['node_count'] = config.get('GIP', "sc_nodes_%s" % i) 
      subcluster['cpu_model'] = config.get('GIP', "sc_model_%s" % i) 
      subcluster['cpu_vendor'] = config.get('GIP', "sc_vendor_%s" % i) 
      subcluster['ram_mb'] = config.get('GIP', "sc_ramsize_%s" % i) 
      subcluster['cpu_speed_mhz'] = config.get('GIP', "sc_clock_%s" % i) 
      subcluster['cpus_per_node'] = config.get('GIP', "sc_numpcpus_%s" % i) 
      subcluster['cores_per_node'] = config.get('GIP', "sc_numlcpus_%s" % i) 
      subcluster['inbound_network'] = config.get('GIP', "sc_inbound_%s" % i) 
      subcluster['outbound_network'] = config.get('GIP', "sc_outbound_%s" % i)
      config.remove_option('GIP', "sc_name_%s" % i) 
      config.remove_option('GIP', "sc_nodes_%s" % i) 
      config.remove_option('GIP', "sc_model_%s" % i) 
      config.remove_option('GIP', "sc_vendor_%s" % i) 
      config.remove_option('GIP', "sc_clock_%s" % i) 
      config.remove_option('GIP', "sc_numpcpu_%s" % i) 
      config.remove_option('GIP', "sc_numlcpu_%s" % i) 
      config.remove_option('GIP', "sc_inbound_%s" % i) 
      config.remove_option('GIP', "sc_outbound_%s" % i)
      subclusters.append(subcluster)
    for subcluster in subclusters:
      section_name = "Subcluster %s" % subcluster['name']
      config.add_section(section_name)
      for key in subcluster:      
        config.set(section_name, key, subcluster[key])
    
    storage = {'name' : 'SE CHANGEME'}
    if config.has_option('GIP', 'se_name'):
      storage['se_name'] = config.get('GIP', 'se_name')
      storage['name'] = "SE %s" % config.get('GIP', 'se_name')    
    if config.has_option('GIP', 'srm_endpoint'):
      storage['srm_endpoint'] = config.get('GIP', 'srm_endpoint')
    if config.has_option('GIP', 'srm_version'):
      storage['version'] = config.get('GIP', 'srm_version')
    if config.has_option('GIP', 'provider_implementation'):
      storage['provider_implementation'] = config.get('GIP', 'provider_implementation')
    if config.has_option('GIP', 'vo_dir'):
      storage['default_path'] = config.get('GIP', 'vo_dir')
    if config.has_option('GIP', 'srm_implementation'):
      storage['implementation'] = config.get('GIP', 'srm_implementation')
      
    if storage['name'] != 'SE CHANGEME':
      section_name = storage['name'] 
      config.add_section(storage['name'])
      for key in storage:
        config.set(storage['name'], key, storage[key]) 
    
  # remove old options from gip section
  current_options = ['batch', 'advertise_gsiftp', 'advertise_gums', 'gsiftp_host']  
  gip_options = config.options('GIP')
  for option in gip_options:
    if option not in current_options:
      config.remove_option('GIP', option)

  return config
  
def parse_attributes(attributes_file):
  """
  Parse attributes file and generate a config file from it
  """

  # get base path for attribute files
  base_path = "/".join(attributes_file.split('/')[:-1])
  # read osg-attributes.conf and parse it
  attribute_regex = re.compile(r'([A-Z0-9_]*)="(.*)"')
  attributes = []
  try:
    handle = open(attributes_file)
    for line in handle:
      if attribute_regex.search(line):
        match = attribute_regex.search(line)
        attributes.append((match.group(1), match.group(2)))
  except:
    error_exit("Can't open and parse osg_attributes file: %s" % attributes_file)
  
  
  # setup configuration file
  config = ConfigParser.ConfigParser()
  extract_base = os.path.join(utilities.get_vdt_location(),
                              'osg',
                              "etc",
                              "configure-osg-templates", 
                              "extract-config.ini")
  if utilities.valid_file(extract_base):
    try:
      config.readfp(open(extract_base))
    except:
      logger.warn("Can't read configuration template," +
                  "you may need to add settings to your template")
      
  # parse gip-attributes, this is trickier than osg-attributes due to formatting
  # of the variable declarations
  gip_attributes = os.path.join(base_path, "gip-attributes.conf")
  if utilities.valid_file(gip_attributes):
    gip_regex = re.compile(r'\s*([A-Z0-9\[\]]*)\s*=\s*"([a-zA-Z0-9._-]+)"')
    temp = {}
    subcluster_index = 0
    subclusters = []
    try:
      handle = open(attributes_file)
      parsing = False
      for line in handle:
        if re.search('#---\s*VARIABLES ', line, re.I):
          parsing = True
          continue
        elif re.search('#---\s*EXPORT VARIABLES ', line, re.I):
          parsing = False
          continue        
        elif not parsing or line[0] == '#': 
          continue                
        
        fields = line.strip().split('=')        
        if fields[0] == 'OSG_GIP_BATCH':
          config.set('GIP', 'batch', re.sub('"', '', fields[1]))
        elif fields[0] == 'OSG_GIP_GUMS':
          value = re.sub('"', '', fields[1])
          if value == '0':
            config.set('GIP', 'advertise_gums', 'False')
          else:
            config.set('GIP', 'advertise_gums', 'True')
        elif fields[0] == 'OSG_SE_DISK':
          config.set('GIP', 'gsiftp_host', re.sub('"', '', fields[1]))
        elif fields[0] == 'OSG_GIP_SC_NUMBER':
          try:
            subclusters = int(re.sub('"', '', fields[1]))
          except:
            pass                          
        temp[fields[0]] = re.sub('"', '', fields[1])
      
      # parse subcluster information    
      if subcluster_index > 0:
        for i in range(subcluster_index):
          subcluster = {}
          if "OSG_GIP_SC_ARR[%s01]" % i in temp:
            subcluster['name'] = temp["OSG_GIP_SC_ARR[%s01]" % i]
          if "OSG_GIP_SC_ARR[%s02]" % i in temp:
            subcluster['cpu_vendor'] = temp["OSG_GIP_SC_ARR[%s02]" % i]
          if "OSG_GIP_SC_ARR[%s03]" % i in temp:
            subcluster['cpu_model'] = temp["OSG_GIP_SC_ARR[%s03]" % i]
          if "OSG_GIP_SC_ARR[%s04]" % i in temp:
            subcluster['cpu_speed_mhz'] = temp["OSG_GIP_SC_ARR[%s04]" % i]
          if "OSG_GIP_SC_ARR[%s05]" % i in temp:
            subcluster['cpus_per_node'] = temp["OSG_GIP_SC_ARR[%s05]" % i]
          if "OSG_GIP_SC_ARR[%s06]" % i in temp:
            subcluster['cores_per_node'] = temp["OSG_GIP_SC_ARR[%s06]" % i]
          if "OSG_GIP_SC_ARR[%s11]" % i in temp:
            subcluster['ram_mb'] = temp["OSG_GIP_SC_ARR[%s06]" % i]
          if "OSG_GIP_SC_ARR[%s21]" % i in temp:
            subcluster['inbound'] = temp["OSG_GIP_SC_ARR[%s21]" % i]
          if "OSG_GIP_SC_ARR[%s22]" % i in temp:
            subcluster['outbound'] = temp["OSG_GIP_SC_ARR[%s22]" % i]
          if "OSG_GIP_SC_ARR[%s99]" % i in temp:
            subcluster['node_count'] = temp["OSG_GIP_SC_ARR[%s99]" % i]
        # create subcluster entries
        for subcluster in subclusters:
          section_name = "Subcluster %s" % subcluster['name']
          config.add_section(section_name)
          for key in subcluster:      
            config.set(section_name, key, subcluster[key])
        # parse se information
        storage = {}
        if 'OSG_GIP_SE_NAME' in temp:
          section_name = "SE %s" % temp['OSG_GIP_SE_NAME']
          config.add_section(section_name)
          config.set(section_name, 'name', temp['OSG_GIP_SE_NAME'])
          if 'OSG_GIP_SE_HOST' in temp:            
            config.set(section_name, 'srm_endpoint', temp['OSG_GIP_SE_HOST'])
          config.set(section_name, 'version', 'CHANGEME')
          config.set(section_name, 'implementation', 'CHANGEME')
          config.set(section_name, 'provider_implementation', 'CHANGEME')
    except:
      error_exit("Can't open and parse gip_attributes file: %s" % attributes_file)

  local_attributes = os.path.join(base_path, "local-job-environment.conf")
  if utilities.valid_file(local_attributes):
    config.add_section('Local Settings')
    try:
      handle = open(local_attributes)
      for line in handle:
        if attribute_regex.search(line):
          match = attribute_regex.search(line)
          config.set('Local Settings', match.group(1), match.group(2))
    except:
      error_exit("Can't open and parse local settings file: %s" % attributes_file)

  # Sort attributes to make generated config file nicer (options in alpha order)
  attributes.sort()
  
  for module in modules:
    module.generateConfigFile(attributes, config)
  
  for section in config.sections():
    if len(config.options(section)) == 0:
      config.remove_section(section)
  return config

def extract_configuration(output_file, old_install, modules):
  """Read attributes files and generate a configuration file that recreates 
  those attributes
  """
  if modules == []:
    error_exit("No modules found, exiting")
    
  if not utilities.valid_location(old_install):
    error_exit("Old installation not found: %s" % old_install)
  if utilities.valid_file(output_file):
    error_exit("Output file exists, will not overwrite: %s" % output_file)
  
  
  old_config_file = os.path.join(old_install, 'osg', 'etc', 'config.ini')
  old_config_file2 = os.path.join(old_install, 'monitoring', 'config.ini')
  attributes_file = os.path.join(old_install, 'monitoring', 'osg-attributes.conf')
  if utilities.valid_file(old_config_file):
    sys.stdout.write("Using config.ini found in old install: %s\n" % old_config_file)
    config_file = parse_config(old_config_file)
  elif utilities.valid_file(old_config_file2):
    sys.stdout.write("Using config.ini found in old install: %s\n" % old_config_file2)
    config_file = parse_config(old_config_file2)
  elif utilities.valid_file(attributes_file):
    config_file = parse_attributes(attributes_file, old_install)
  else:
    sys.stderr.write("Can't find osg-attributes.conf or config.ini, giving up\n")
    error_exit("Can't find old configuration information")
    
      
  try:
    config_file.write(open(output_file, 'w'))
  except Exception, e:
    
    error_exit("Can't write to output_file: %s\n%s" % (output_file, e))
    
  sys.stdout.write("You will need to modify the extracted configuration to fill in values for new values.")
  return True
  
  
############################# Main Program ##############################

def main():
  global error_exit
  global normal_exit
  
  normal_exit_message = "Configuration completed, exiting..."
  error_exit_message = "Critical error occurred, exiting..."
    
  mode = None
  configure_mode = None
  
  if py23:
    log_level = logging.INFO
  else:                          
    log_level = "info"           
  
  # include application path in list of directories that python checks
  set_python_path()
  
  # get $VDT_LOCATION from environment
  try:
    vdt_location = utilities.get_vdt_location()
  except exceptions.ApplicationError:
    sys.stderr.write("VDT_LOCATION not set, please run setup.sh before trying ")
    sys.stderr.write("to configure your install.\n")
    sys.exit(1)
  
  # log information to vdt-install.log
  
  os.system("/bin/echo '##########' >> %s/vdt-install.log" % vdt_location)
  os.system("/bin/echo '# extract-config.py invoked at %s' >> %s/vdt-install.log" % (time.ctime(), vdt_location))
  os.system("/bin/echo '##########' >> %s/vdt-install.log" % vdt_location)
  atexit.register(vdt_finish)
  
  try:
    opts, args = getopt.getopt(sys.argv[1:], 'lhdf:D:cvem:', ['force'])
  except getopt.GetoptError:
    usage()
    sys.stderr.write("Can't parse commandline arguments\n")
    sys.exit(1)
  
  config_directory = None
  configure_module = None
  for opt,parameter in opts:
    if opt == "-d": 
      if py23:
        log_level = logging.DEBUG
      else:            
        log_level = "debug"
    elif opt == "-h":
      usage()
      sys.exit(0)
      
    
  sys.stdout.write("Writing new configuration to  ./extracted-config.ini\n")
  configuration_file = "extracted-config.ini"
  if 'OLD_VDT_LOCATION' in os.environ:
    config_directory = os.environ['OLD_VDT_LOCATION']
  else:
    sys.stderr.write("OLD_VDT_LOCATION must be in the environment to extract a configuration\n")
    usage()
    sys.exit(1)
    
  # setup logging
  try:
    if py23:
      logger = logging.getLogger('extract-config')
      formatter = logging.Formatter('### %(asctime)s extract-config %(levelname)s %(message)s')
      handler = logging.FileHandler("%s/vdt-install.log" % (vdt_location), 'a')
      logger.setLevel(log_level)
      handler.setFormatter(formatter)
      logger.addHandler(handler)
      error_exit = lambda mesg=error_exit_message, exception=None: real_error_exit(logger, mesg, exception)    
      normal_exit = lambda mesg=normal_exit_message: real_normal_exit(logger, mesg)
      
    else:
      logger = FakeLogger(log_level)
      error_exit = lambda mesg=error_exit_message, exception=None: real_error_exit(logger, mesg, exception)
      normal_exit = lambda mesg=normal_exit_message: real_normal_exit(logger, mesg)
      
  except IOError:
    sys.stderr.write("Can't open vdt-install.log for logging, exiting...\n")
    sys.exit(1)
  
  try:
    # get a list of configuration modules
    modules = get_configuration_modules(vdt_location, logger)
    
    extract_configuration(configuration_file, config_directory, modules)
  except SystemExit:
    # needed since SystemExit inherits from Exception
    raise
  except Exception, e:
    sys.stderr.write("Please contact the developer, an unknown error occurred\n")
    error_exit("Unknown exception encountered while running: %s" % e)  
  
  normal_exit("%s completed successfully" % sys.argv[0])
  
  
if __name__ == '__main__':
    main()
